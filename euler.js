// Generated by CoffeeScript 1.4.0
(function() {
  var clone, combinations;

  exports.digits = function(num) {
    var list;
    list = [];
    while (num > 0) {
      list.push(num % 10);
      num = Math.floor(num / 10);
    }
    return list.reverse();
  };

  exports.isPalindrome = function(digits) {
    var i, len, _i, _ref;
    len = digits.length;
    for (i = _i = 0, _ref = Math.floor(len / 2); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (digits[i] !== digits[len - i - 1]) {
        return false;
      }
    }
    return true;
  };

  exports.digitsToNumber = function(digits) {
    var d, sum, _i, _len;
    sum = 0;
    for (_i = 0, _len = digits.length; _i < _len; _i++) {
      d = digits[_i];
      sum *= 10;
      sum += d;
    }
    return sum;
  };

  exports.isPrime = function(n) {
    var i, _i, _ref;
    if (n < 2) {
      return false;
    }
    if (n === 2) {
      return true;
    }
    if (n % 2 === 0) {
      return false;
    }
    for (i = _i = 3, _ref = Math.floor(Math.sqrt(n)); _i <= _ref; i = _i += 2) {
      if (n % i === 0) {
        return false;
      }
    }
    return true;
  };

  exports.combinations = function(list, n) {
    var combs, i, indices, _i, _len, _results;
    combs = combinations(list.length, n);
    _results = [];
    for (_i = 0, _len = combs.length; _i < _len; _i++) {
      indices = combs[_i];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = indices.length; _j < _len1; _j++) {
          i = indices[_j];
          _results1.push(list[i]);
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.repcombinations = function(arr, k) {
    var combo, combos_sans_head, combos_with_head;
    if (k === 0) {
      return [[]];
    }
    if (arr.length === 0) {
      return [];
    }
    combos_with_head = (function() {
      var _i, _len, _ref, _results;
      _ref = exports.repcombinations(arr, k - 1);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        combo = _ref[_i];
        _results.push([arr[0]].concat(combo));
      }
      return _results;
    })();
    combos_sans_head = exports.repcombinations(arr.slice(1), k);
    return combos_with_head.concat(combos_sans_head);
  };

  exports.factorial = function(n) {
    if (n > 0) {
      return n * exports.factorial(n - 1);
    } else {
      return 1;
    }
  };

  exports.counter = function(list) {
    var sums, x, _i, _len;
    sums = {};
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      x = list[_i];
      sums[x] = (sums[x] ? sums[x] + 1 : 1);
    }
    return sums;
  };

  clone = function(arr) {
    var n, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      n = arr[_i];
      _results.push(n);
    }
    return _results;
  };

  combinations = function(n, p) {
    var combo, combos, i;
    if (p === 0) {
      return [[]];
    }
    i = 0;
    combos = [];
    combo = [];
    while (combo.length < p) {
      if (i < n) {
        combo.push(i);
        i += 1;
      } else {
        if (combo.length === 0) {
          break;
        }
        i = combo.pop() + 1;
      }
      if (combo.length === p) {
        combos.push(clone(combo));
        i = combo.pop() + 1;
      }
    }
    return combos;
  };

}).call(this);
